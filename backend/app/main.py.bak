from fastapi import FastAPI, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from fastapi.middleware.cors import CORSMiddleware
from sqlalchemy.orm import Session
from datetime import datetime, timedelta
from typing import List, Optional
import uvicorn

from .database import get_db, engine
from .models import Base, User, Alert, FileEvent
from .schemas import UserCreate, UserResponse, Token, AlertResponse, FileEventResponse, MetricsResponse
from .auth import authenticate_user, create_access_token, get_current_user, get_password_hash

Base.metadata.create_all(bind=engine)

app = FastAPI(title="RansomGuard API", version="1.0.0")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

@app.post("/register", response_model=UserResponse)
async def register(user: UserCreate, db: Session = Depends(get_db)):
    db_user = db.query(User).filter(User.email == user.email).first()
    if db_user:
        raise HTTPException(
            status_code=400,
            detail="Email already registered"
        )
    
    hashed_password = get_password_hash(user.password)
    db_user = User(
        email=user.email,
        hashed_password=hashed_password,
        first_name=user.first_name,
        last_name=user.last_name
    )
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    return db_user

@app.post("/token", response_model=Token)
async def login(form_data: OAuth2PasswordRequestForm = Depends(), db: Session = Depends(get_db)):
    user = authenticate_user(db, form_data.username, form_data.password)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect email or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    access_token_expires = timedelta(minutes=30)
    access_token = create_access_token(
        data={"sub": user.email}, expires_delta=access_token_expires
    )
    return {"access_token": access_token, "token_type": "bearer"}

@app.get("/users/me", response_model=UserResponse)
async def read_users_me(current_user: User = Depends(get_current_user)):
    return current_user

@app.get("/alerts", response_model=List[AlertResponse])
async def get_alerts(
    skip: int = 0,
    limit: int = 100,
    severity: Optional[str] = None,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    query = db.query(Alert)
    if severity:
        query = query.filter(Alert.severity == severity)
    alerts = query.offset(skip).limit(limit).all()
    return alerts

@app.get("/file-events", response_model=List[FileEventResponse])
async def get_file_events(
    skip: int = 0,
    limit: int = 50,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    events = db.query(FileEvent).offset(skip).limit(limit).all()
    return events

@app.get("/metrics", response_model=MetricsResponse)
async def get_metrics(current_user: User = Depends(get_current_user), db: Session = Depends(get_db)):
    total_alerts = db.query(Alert).count()
    critical_alerts = db.query(Alert).filter(Alert.severity == "critical").count()
    high_alerts = db.query(Alert).filter(Alert.severity == "high").count()
    ransomware_alerts = db.query(Alert).filter(Alert.type == "Ransomware").count()
    raas_alerts = db.query(Alert).filter(Alert.type == "RaaS").count()
    
    return MetricsResponse(
        total_alerts=total_alerts,
        critical_alerts=critical_alerts,
        high_alerts=high_alerts,
        ransomware_alerts=ransomware_alerts,
        raas_alerts=raas_alerts
    )

@app.post("/alerts", response_model=AlertResponse)
async def create_alert(
    alert: dict,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    db_alert = Alert(
        host=alert.get("host"),
        path=alert.get("path"),
        severity=alert.get("severity"),
        fme=alert.get("fme"),
        abt=alert.get("abt"),
        type=alert.get("type")
    )
    db.add(db_alert)
    db.commit()
    db.refresh(db_alert)
    return db_alert

@app.post("/file-events", response_model=FileEventResponse)
async def create_file_event(
    event: dict,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    db_event = FileEvent(
        path=event.get("path"),
        action=event.get("action"),
        fme=event.get("fme")
    )
    db.add(db_event)
    db.commit()
    db.refresh(db_event)
    return db_event

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)
